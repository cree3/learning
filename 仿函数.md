## 导语

STL算法提供两个版本：
- 最常用的版本，eg：sort第一个版本以operator<实现
- 允许用户指定操作，将“操作”当作算法参数：
- 1、将操作设计为一个函数，将函数指针当作参数；
- 2、把操作设计为设计一个仿函数，由仿函数产生一个对象，并以该对象当作参数

使用仿函数而不是函数的指针的原因：函数指针不能满足STL抽象性的要求

**仿函数**：一个“行为类似函数”的对象，其类型定义中必须自定义operator（）

**仿函数用法**：可以使用stl内建的访函数，也可以使用用户自定义的仿函数；

欲使用STL内建的仿函数，包含<stl_functional>头文件

eg：greater<int>()(6,4),产生一个临时对象

**仿函数分类**：

- 以操作数分：一元、二员；
- 以功能分：算数运算、关系运算、逻辑运算

## 可配接(adaptable)的关键
**仿函数的策略**：？

**仿函数实现可配接**：
- 为了让适配器获取仿函数的信息，向迭代器一样，仿函数需要定义自己的型别。
- 仿函数的相应型别主要用来表示函数参数型别和返回值型别

#### **unary_function**：
呈现一元函数的参数型别和返回值型别

```
template<class Arg,class Result>
struct unary_function{
    typedef Arg argument_type;
    typedef Result result_type;
}
```
当某个仿函数继承uniary_function时，可这样获得仿函数的参数型别

```
//某个仿函数
template<classs T>
struct negate:public unary_function<T,T>
{
    T operator()(const T& x) const {return -x;}
}
//某个适配器
template<class Predicate>
class unary_negate
{
    ...
    public:
    bool operator()(const typedef Predicate::argument_type &x)const{
        .....
    }
}

```

#### **binary_function**：
呈现二元函数的第一、第二参数型别，以及返回值型别

```
template<class Arg1,class Arg2,class Result>
struct binary_function{
    typedef Arg1 first_argument_type;
    typedef Arg2 second_argument_type;
    typedef Result result_type;
}
```
用法与一元的仿函数用法类似。

## 算法类仿函数
算数类仿函数支持“+”、“-”、“*”、“/”、“%”、否定“-”；除了否定运算是一元运算，其他都是二元运算。

- plus<T>
- minus<T>
- multiplies<T>
- divedes<T>
- modules<T>
- negate<T>

仿函数的主要用途是为了搭配stl算法

```
accumulate(iv.begin(),iv.end(),multiplies<int>());
```
**证同元素**
运算op的证同元素，意思是数值A若与该元素做op运算，得到A自己。

## 关系类仿函数
共有六种，都是二元运算
- equal_to<T>
- not_equal_to<T>
- greater<T>
- greater_equal<T>
- less<T>
- lesss_equal<T>

```
sort(ivec.begin(),ivec.end(),greater<int>());
```
## 逻辑运算类仿函数
支持逻一元辑运算中的And、Or、Not三种运算，其中只有Not是函数

- logical_and<T>
- logical_or<T>
- logical_not<T>

## 证同、选择、投射
**证同函数**：任何数值通过此函数，不会有任何变化；用来指定RB_Tree所需的KeyOfValue op，因为set元素的键值即实值。

**选择函数**：

select1st：接受一个pair，传回其第一元素；用于指定RB_tree所需的KeyOfValue op，因为map是以pair元素的第一元素为键值。

select2nd：接手一个pair，传回其第二元素；

**投射函数**：

project1st：传回第一参数，忽略第二参数

project2nd：传回第二参数，忽略第一参数

